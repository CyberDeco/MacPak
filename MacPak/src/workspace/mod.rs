//! Workspace management for MacPak mod projects
//!
//! A workspace represents a mod project on disk with a `macpak.toml` manifest,
//! a recipe describing the expected structure, and file status tracking.

pub mod project;
pub mod recipe;
pub mod scaffold;
pub mod settings;

use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};

use maclarian::mods::validation::{ModValidationResult, validate_mod_structure};
use maclarian::pak::{CompressionMethod, PakOperations};

use project::ProjectManifest;
use recipe::{FileKind, Recipe, find_recipe, substitute};
use scaffold::scaffold_project;

/// Status of a file in the workspace
#[derive(Debug, Clone, PartialEq)]
pub enum FileStatus {
    /// File exists on disk
    Present,
    /// Required file is missing
    Missing,
    /// Optional file is missing (not an error)
    MissingOptional,
    /// File was auto-generated by MacPak
    Generated,
}

/// A workspace representing an open mod project
#[derive(Debug, Clone)]
pub struct Workspace {
    /// Root directory of the project
    pub project_dir: PathBuf,
    /// The project manifest (macpak.toml)
    pub manifest: ProjectManifest,
    /// The recipe used for this project
    pub recipe: Recipe,
    /// File path -> status mapping
    pub file_status: HashMap<String, FileStatus>,
}

impl Workspace {
    /// Create a new project from a manifest.
    ///
    /// Scaffolds the directory structure and generated files on disk.
    pub fn create(
        project_dir: impl AsRef<Path>,
        manifest: ProjectManifest,
    ) -> Result<Self, String> {
        let project_dir = project_dir.as_ref().to_path_buf();

        let recipe = find_recipe(&manifest.project.recipe)
            .ok_or_else(|| format!("Unknown recipe: {}", manifest.project.recipe))?;

        scaffold_project(&project_dir, &manifest, &recipe)?;

        let mut ws = Self {
            project_dir,
            manifest,
            recipe,
            file_status: HashMap::new(),
        };
        ws.refresh_status();
        Ok(ws)
    }

    /// Open an existing project from its directory (reads macpak.toml).
    pub fn open(project_dir: impl AsRef<Path>) -> Result<Self, String> {
        let project_dir = project_dir.as_ref().to_path_buf();
        let manifest_path = project_dir.join("macpak.toml");

        if !manifest_path.exists() {
            return Err(format!("No macpak.toml found in {}", project_dir.display()));
        }

        let content = fs::read_to_string(&manifest_path)
            .map_err(|e| format!("Failed to read macpak.toml: {}", e))?;

        let manifest: ProjectManifest =
            toml::from_str(&content).map_err(|e| format!("Failed to parse macpak.toml: {}", e))?;

        let recipe = find_recipe(&manifest.project.recipe)
            .ok_or_else(|| format!("Unknown recipe: {}", manifest.project.recipe))?;

        let mut ws = Self {
            project_dir,
            manifest,
            recipe,
            file_status: HashMap::new(),
        };
        ws.refresh_status();
        Ok(ws)
    }

    /// Save the manifest to disk (macpak.toml).
    pub fn save(&self) -> Result<(), String> {
        let manifest_toml = toml::to_string_pretty(&self.manifest)
            .map_err(|e| format!("Failed to serialize manifest: {}", e))?;
        fs::write(self.project_dir.join("macpak.toml"), manifest_toml)
            .map_err(|e| format!("Failed to write macpak.toml: {}", e))
    }

    /// Refresh file status by checking which files exist on disk.
    pub fn refresh_status(&mut self) {
        let vars = self.build_vars();
        self.file_status.clear();

        for file in &self.recipe.files {
            let path = substitute(&file.path, &vars);
            let full_path = self.project_dir.join(&path);

            let status = if full_path.exists() {
                if file.kind == FileKind::Generated {
                    FileStatus::Generated
                } else {
                    FileStatus::Present
                }
            } else if file.kind == FileKind::Optional {
                FileStatus::MissingOptional
            } else {
                FileStatus::Missing
            };

            self.file_status.insert(path, status);
        }
    }

    /// Validate the project structure using MacLarian's validator.
    pub fn validate(&self) -> ModValidationResult {
        validate_mod_structure(&self.project_dir)
    }

    /// Build the project into a PAK file.
    ///
    /// Returns the path to the output PAK on success.
    pub fn build(&self) -> Result<PathBuf, String> {
        // Refresh and check for missing required files
        let vars = self.build_vars();
        for file in &self.recipe.files {
            if file.kind == FileKind::Optional {
                continue;
            }
            let path = substitute(&file.path, &vars);
            let full_path = self.project_dir.join(&path);
            if !full_path.exists() {
                return Err(format!("Required file missing: {}", path));
            }
        }

        // Validate structure
        let validation = self.validate();
        if !validation.valid {
            let warnings = validation.warnings.join(", ");
            return Err(format!("Validation failed: {}", warnings));
        }

        // Determine output path
        let output_dir = self.project_dir.join(&self.manifest.build.output_dir);
        fs::create_dir_all(&output_dir)
            .map_err(|e| format!("Failed to create output directory: {}", e))?;

        let pak_name = format!("{}.pak", self.manifest.project.folder);
        let output_pak = output_dir.join(&pak_name);

        // Determine compression
        let compression = match self.manifest.build.compression.to_lowercase().as_str() {
            "none" => CompressionMethod::None,
            "zlib" => CompressionMethod::Zlib,
            _ => CompressionMethod::Lz4,
        };

        // Create PAK
        PakOperations::create_with_compression_and_progress(
            &self.project_dir,
            &output_pak,
            compression,
            &|_| {},
        )
        .map_err(|e| format!("Failed to create PAK: {}", e))?;

        // Generate info.json if requested
        if self.manifest.build.generate_info_json {
            let _ = maclarian::mods::generate_info_json_from_source(&output_pak, &|_| {});
        }

        Ok(output_pak)
    }

    /// Get the default base directory for new projects.
    #[cfg(feature = "gui")]
    pub fn default_projects_dir() -> PathBuf {
        dirs::document_dir()
            .unwrap_or_else(|| PathBuf::from("~"))
            .join("MacPak")
    }

    /// Get the default base directory for new projects (non-GUI fallback).
    #[cfg(not(feature = "gui"))]
    pub fn default_projects_dir() -> PathBuf {
        PathBuf::from(".")
    }

    /// Build template variable map from the current manifest.
    fn build_vars(&self) -> HashMap<String, String> {
        let mut vars = HashMap::new();
        vars.insert("mod_name".to_string(), self.manifest.project.folder.clone());
        vars.insert("uuid".to_string(), self.manifest.project.uuid.clone());
        vars.insert("author".to_string(), self.manifest.project.author.clone());
        vars.insert("version".to_string(), self.manifest.project.version.clone());
        for (key, value) in &self.manifest.variables {
            vars.insert(key.clone(), value.clone());
        }
        vars
    }

    /// Get the resolved (substituted) path for a recipe file entry.
    pub fn resolve_path(&self, template_path: &str) -> PathBuf {
        let vars = self.build_vars();
        let resolved = substitute(template_path, &vars);
        self.project_dir.join(resolved)
    }
}
